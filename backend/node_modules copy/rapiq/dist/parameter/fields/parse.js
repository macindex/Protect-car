"use strict";
/*
 * Copyright (c) 2021-2022.
 * Author Peter Placzek (tada5hi)
 * For the full copyright and license information,
 * view the LICENSE file that was distributed with this source code.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseQueryFields = exports.replaceRecordKey = void 0;
const utils_1 = require("../../utils");
const utils_2 = require("./utils");
const constants_1 = require("../../constants");
// --------------------------------------------------
function buildReverseRecord(record) {
    const keys = Object.keys(record);
    const output = {};
    for (let i = 0; i < keys.length; i++) {
        output[record[keys[i]]] = keys[i];
    }
    return output;
}
function replaceRecordKey(record, key, newKey) {
    if ((0, utils_1.hasOwnProperty)(record, key)) {
        const value = record[key];
        delete record[key];
        record[newKey] = value;
    }
    return record;
}
exports.replaceRecordKey = replaceRecordKey;
function parseQueryFields(data, options) {
    var _a;
    options !== null && options !== void 0 ? options : (options = {});
    const defaultDomainFields = (0, utils_2.buildFieldDomainRecords)(options.default);
    const domainFields = (0, utils_2.mergeFieldsDomainRecords)((0, utils_2.buildFieldDomainRecords)(options.allowed), Object.assign({}, defaultDomainFields));
    let domainKeys = Object.keys(domainFields);
    // If it is an empty array nothing is allowed
    if (domainKeys.length === 0) {
        return [];
    }
    if (options.defaultAlias) {
        if ((0, utils_1.hasOwnProperty)(defaultDomainFields, constants_1.DEFAULT_ALIAS_ID)) {
            replaceRecordKey(defaultDomainFields, constants_1.DEFAULT_ALIAS_ID, options.defaultAlias);
        }
        if ((0, utils_1.hasOwnProperty)(domainFields, constants_1.DEFAULT_ALIAS_ID)) {
            replaceRecordKey(domainFields, constants_1.DEFAULT_ALIAS_ID, options.defaultAlias);
        }
    }
    domainKeys = Object.keys(domainFields);
    let defaultAlias;
    if (domainKeys.length === 1 &&
        !options.defaultAlias) {
        // eslint-disable-next-line prefer-destructuring
        defaultAlias = domainKeys[0];
    }
    else {
        defaultAlias = options.defaultAlias || constants_1.DEFAULT_ALIAS_ID;
    }
    options.defaultAlias = defaultAlias;
    const prototype = Object.prototype.toString.call(data);
    if (prototype !== '[object Object]' &&
        prototype !== '[object Array]' &&
        prototype !== '[object String]') {
        data = { [defaultAlias]: [] };
    }
    if (prototype === '[object String]') {
        data = { [defaultAlias]: data };
    }
    if (prototype === '[object Array]') {
        data = { [defaultAlias]: data };
    }
    (_a = options.aliasMapping) !== null && _a !== void 0 ? _a : (options.aliasMapping = {});
    const reverseAliasMapping = buildReverseRecord(options.aliasMapping);
    const output = [];
    for (let i = 0; i < domainKeys.length; i++) {
        const domainKey = domainKeys[i];
        if (!(0, utils_1.isAllowedByRelations)({ alias: domainKey }, options.relations, options.defaultAlias)) {
            continue;
        }
        let fields = [];
        if ((0, utils_1.hasOwnProperty)(data, domainKey)) {
            fields = (0, utils_2.parseFieldsInput)(data[domainKey]);
        }
        else if ((0, utils_1.hasOwnProperty)(reverseAliasMapping, domainKey)) {
            if ((0, utils_1.hasOwnProperty)(data, reverseAliasMapping[domainKey])) {
                fields = (0, utils_2.parseFieldsInput)(data[reverseAliasMapping[domainKey]]);
            }
        }
        let transformed = {
            default: [],
            included: [],
            excluded: [],
        };
        if (fields.length > 0) {
            for (let j = 0; j < fields.length; j++) {
                fields[j] = (0, utils_1.getNameByAliasMapping)((0, utils_1.buildFieldWithAlias)({ name: fields[j], alias: domainKey }), options.aliasMapping, true);
            }
            fields = fields
                .filter((field) => domainFields[domainKey].indexOf((0, utils_2.removeFieldInputOperator)(field)) !== -1);
            transformed = (0, utils_2.transformFieldsInput)(fields);
        }
        if (transformed.default.length === 0) {
            if ((0, utils_1.hasOwnProperty)(defaultDomainFields, domainKey)) {
                transformed.default = defaultDomainFields[domainKey];
            }
            if (transformed.included.length === 0 &&
                transformed.default.length === 0 &&
                (0, utils_1.hasOwnProperty)(domainFields, domainKey)) {
                transformed.default = domainFields[domainKey];
            }
        }
        transformed.default = Array.from(new Set([
            ...transformed.default,
            ...transformed.included,
        ]));
        for (let j = 0; j < transformed.excluded.length; j++) {
            const index = transformed.default.indexOf(transformed.excluded[j]);
            if (index !== -1) {
                transformed.default.splice(index, 1);
            }
        }
        if (transformed.default.length > 0) {
            for (let j = 0; j < transformed.default.length; j++) {
                output.push(Object.assign({ key: transformed.default[j] }, (domainKey !== constants_1.DEFAULT_ALIAS_ID ? { alias: domainKey } : {})));
            }
        }
    }
    return output;
}
exports.parseQueryFields = parseQueryFields;
//# sourceMappingURL=parse.js.map